/**
 * K8s Penetration Testing API Service
 * Comprehensive security testing framework for Kubernetes environments
 * 
 * BACKEND DEPLOYMENT REQUIREMENTS:
 * 1. Metasploit Framework: Container with msfconsole and msfvenom
 * 2. Nmap: Advanced network scanning container
 * 3. Burp Suite Professional: Headless scanner container
 * 4. Custom K8s Security Tools: kubectl, kube-hunter, kube-bench
 * 5. Evidence Storage: Persistent volumes for screenshots, logs, reports
 * 
 * SECURITY CONSIDERATIONS:
 * - All pentest containers run in isolated namespaces
 * - RBAC policies restrict access to target namespaces only
 * - Network policies prevent lateral movement
 * - All activities logged and audited
 * - Evidence encrypted at rest
 */

import { 
  PenetrationTarget, 
  K8sTarget, 
  PentestSession, 
  PentestFinding, 
  PentestEvidence,
  K8sSecurityTest,
  MetasploitConfig,
  NmapConfig,
  BurpConfig,
  PentestToolStatus,
  PentestApiResponse,
  PentestWSMessage
} from '@/types/penetration';

class K8sPentestApiService {
  private baseUrl: string;
  private wsConnection: WebSocket | null = null;
  private activeSession: string | null = null;

  constructor() {
    // K8s service discovery for pentest backend
    this.baseUrl = import.meta.env?.PROD
      ? 'https://pentest-api.security.svc.cluster.local'
      : 'http://localhost:3002';
    
    this.initializeWebSocket();
  }

  /**
   * Initialize WebSocket for real-time pentest updates
   */
  private initializeWebSocket() {
    const wsUrl = this.baseUrl.replace('http', 'ws') + '/pentest/ws';
    
    try {
      this.wsConnection = new WebSocket(wsUrl);
      
      this.wsConnection.onopen = () => {
        console.log('üîó Pentest WebSocket connected');
      };
      
      this.wsConnection.onmessage = (event) => {
        const message: PentestWSMessage = JSON.parse(event.data);
        this.handleWebSocketMessage(message);
      };
      
      this.wsConnection.onclose = () => {
        console.log('üîó Pentest WebSocket disconnected');
        // Implement reconnection logic
      };
      
    } catch (error) {
      console.error('‚ùå Failed to initialize pentest WebSocket:', error);
    }
  }

  /**
   * Handle incoming WebSocket messages
   */
  private handleWebSocketMessage(message: PentestWSMessage) {
    const event = new CustomEvent(`pentest:${message.type}`, {
      detail: message
    });
    window.dispatchEvent(event);
  }

  /**
   * Generic API request handler
   */
  private async makeRequest<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<PentestApiResponse<T>> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': this.activeSession || '',
          ...options.headers
        }
      });

      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || `HTTP ${response.status}`);
      }

      return {
        success: true,
        data,
        timestamp: new Date().toISOString(),
        sessionId: this.activeSession || undefined
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * K8s Target Discovery
   * Backend Endpoint: GET /api/pentest/discovery/k8s
   */
  async discoverK8sTargets(namespace?: string): Promise<PentestApiResponse<K8sTarget[]>> {
    const queryParams = namespace ? `?namespace=${namespace}` : '';
    return this.makeRequest(`/api/pentest/discovery/k8s${queryParams}`);
  }

  /**
   * Create Penetration Target
   * Backend Endpoint: POST /api/pentest/targets
   */
  async createTarget(target: Omit<PenetrationTarget, 'id' | 'created'>): Promise<PentestApiResponse<PenetrationTarget>> {
    return this.makeRequest('/api/pentest/targets', {
      method: 'POST',
      body: JSON.stringify(target)
    });
  }

  /**
   * Get Available K8s Security Tests
   * Backend Endpoint: GET /api/pentest/k8s-tests
   */
  async getK8sSecurityTests(): Promise<PentestApiResponse<K8sSecurityTest[]>> {
    return this.makeRequest('/api/pentest/k8s-tests');
  }

  /**
   * Create Penetration Test Session
   * Backend Endpoint: POST /api/pentest/sessions
   */
  async createSession(session: Omit<PentestSession, 'id' | 'findings' | 'evidence'>): Promise<PentestApiResponse<PentestSession>> {
    const response = await this.makeRequest<PentestSession>('/api/pentest/sessions', {
      method: 'POST',
      body: JSON.stringify(session)
    });
    
    if (response.success && response.data?.id) {
      this.activeSession = response.data.id;
    }
    
    return response;
  }

  /**
   * Start Nmap Scan
   * Backend Endpoint: POST /api/pentest/tools/nmap/scan
   */
  async startNmapScan(config: {
    targets: string[];
    scanConfig: NmapConfig;
    sessionId: string;
  }): Promise<PentestApiResponse<{ scanId: string }>> {
    return this.makeRequest('/api/pentest/tools/nmap/scan', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Start Metasploit Exploit
   * Backend Endpoint: POST /api/pentest/tools/metasploit/exploit
   */
  async startMetasploitExploit(config: {
    module: string;
    target: string;
    payload: string;
    options: Record<string, any>;
    sessionId: string;
  }): Promise<PentestApiResponse<{ exploitId: string }>> {
    return this.makeRequest('/api/pentest/tools/metasploit/exploit', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Start Burp Suite Scan
   * Backend Endpoint: POST /api/pentest/tools/burp/scan
   */
  async startBurpScan(config: {
    urls: string[];
    scanConfig: BurpConfig;
    sessionId: string;
  }): Promise<PentestApiResponse<{ scanId: string }>> {
    return this.makeRequest('/api/pentest/tools/burp/scan', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Execute K8s Security Test
   * Backend Endpoint: POST /api/pentest/k8s-tests/execute
   */
  async executeK8sTest(config: {
    testId: string;
    targets: K8sTarget[];
    sessionId: string;
  }): Promise<PentestApiResponse<{ executionId: string }>> {
    return this.makeRequest('/api/pentest/k8s-tests/execute', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Upload Evidence
   * Backend Endpoint: POST /api/pentest/evidence
   */
  async uploadEvidence(evidence: {
    sessionId: string;
    type: string;
    title: string;
    content: string;
    severity: string;
    tags: string[];
  }): Promise<PentestApiResponse<PentestEvidence>> {
    return this.makeRequest('/api/pentest/evidence', {
      method: 'POST',
      body: JSON.stringify(evidence)
    });
  }

  /**
   * Get Tool Status
   * Backend Endpoint: GET /api/pentest/tools/status
   */
  async getToolStatus(): Promise<PentestApiResponse<PentestToolStatus>> {
    return this.makeRequest('/api/pentest/tools/status');
  }

  /**
   * Get Session Findings
   * Backend Endpoint: GET /api/pentest/sessions/{sessionId}/findings
   */
  async getSessionFindings(sessionId: string): Promise<PentestApiResponse<PentestFinding[]>> {
    return this.makeRequest(`/api/pentest/sessions/${sessionId}/findings`);
  }

  /**
   * Generate Pentest Report
   * Backend Endpoint: POST /api/pentest/sessions/{sessionId}/report
   */
  async generateReport(sessionId: string, format: 'pdf' | 'html' | 'markdown'): Promise<PentestApiResponse<{ reportUrl: string }>> {
    return this.makeRequest(`/api/pentest/sessions/${sessionId}/report`, {
      method: 'POST',
      body: JSON.stringify({ format })
    });
  }

  /**
   * Execute Custom Script
   * Backend Endpoint: POST /api/pentest/custom/execute
   */
  async executeCustomScript(config: {
    script: string;
    language: 'bash' | 'python' | 'ruby' | 'powershell';
    targets: string[];
    sessionId: string;
  }): Promise<PentestApiResponse<{ executionId: string }>> {
    return this.makeRequest('/api/pentest/custom/execute', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Stop Active Session
   * Backend Endpoint: POST /api/pentest/sessions/{sessionId}/stop
   */
  async stopSession(sessionId: string): Promise<PentestApiResponse<{ message: string }>> {
    const response = await this.makeRequest<{ message: string }>(`/api/pentest/sessions/${sessionId}/stop`, {
      method: 'POST'
    });
    
    if (response.success) {
      this.activeSession = null;
    }
    
    return response;
  }

  /**
   * Cleanup resources
   */
  cleanup() {
    if (this.wsConnection) {
      this.wsConnection.close();
      this.wsConnection = null;
    }
  }
}

// Export singleton instance
export const k8sPentestApi = new K8sPentestApiService();

// Cleanup on page unload
if (typeof window !== 'undefined') {
  window.addEventListener('beforeunload', () => {
    k8sPentestApi.cleanup();
  });
}