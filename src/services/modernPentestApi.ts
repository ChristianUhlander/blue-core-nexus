/**
 * Modern Penetration Testing API Service
 * Comprehensive security testing framework with latest tools and methodologies
 * 
 * Updated with 2024 tools and techniques:
 * - BloodHound CE 5.0+
 * - CrackMapExec/NetExec
 * - Mimikatz latest
 * - Kubernetes security tools (kdigger, kube-hunter, kube-bench)
 * - HackTricks methodology integration
 * - AI-powered analysis with Perplexity research
 * 
 * BACKEND DEPLOYMENT REQUIREMENTS:
 * 1. Active Directory Tools: BloodHound, CrackMapExec, Mimikatz containers
 * 2. Kubernetes Security: kdigger, kube-hunter, kube-bench, kubestriker
 * 3. Network Tools: Nmap, Masscan, Rustscan
 * 4. Web Application: Nuclei, FFUF, SQLMap, Gobuster
 * 5. AI Integration: OpenAI/Anthropic/Perplexity APIs
 * 6. Evidence Storage: Encrypted persistent volumes
 * 7. Compliance: Automated QA and documentation generation
 * 
 * SECURITY CONSIDERATIONS:
 * - Isolated execution environments per tool
 * - RBAC-based access controls
 * - Encrypted evidence storage
 * - Comprehensive audit logging
 * - Real-time monitoring and alerting
 */

import {
  ModernPentestSession,
  PentestTarget,
  ModernToolConfig,
  ModernFinding,
  Evidence,
  ExecutionStep,
  ToolExecution,
  BloodHoundConfig,
  CrackMapExecConfig,
  MimikatzConfig,
  KdiggerConfig,
  KubeHunterConfig,
  KubeBenchConfig,
  NmapConfig,
  HackTricksPhase,
  HackTricksTechnique,
  QAChecklist,
  PentestReport,
  ModernPentestApiResponse,
  ModernPentestWSMessage,
  AIAgentConfig
} from '@/types/modernPentest';

class ModernPentestApiService {
  private baseUrl: string;
  private wsConnection: WebSocket | null = null;
  private activeSession: string | null = null;
  private perplexityApiKey: string | null = null;

  constructor() {
    // K8s service discovery for modern pentest backend
    this.baseUrl = import.meta.env?.PROD
      ? 'https://modern-pentest-api.security.svc.cluster.local'
      : 'http://localhost:3003';
    
    this.initializeWebSocket();
  }

  /**
   * Initialize WebSocket for real-time updates
   */
  private initializeWebSocket() {
    const wsUrl = this.baseUrl.replace('http', 'ws') + '/pentest/ws';
    
    try {
      this.wsConnection = new WebSocket(wsUrl);
      
      this.wsConnection.onopen = () => {
        console.log('üîó Modern Pentest WebSocket connected');
      };
      
      this.wsConnection.onmessage = (event) => {
        const message: ModernPentestWSMessage = JSON.parse(event.data);
        this.handleWebSocketMessage(message);
      };
      
      this.wsConnection.onclose = () => {
        console.log('üîó Modern Pentest WebSocket disconnected');
        setTimeout(() => this.initializeWebSocket(), 5000);
      };
      
    } catch (error) {
      console.error('‚ùå Failed to initialize modern pentest WebSocket:', error);
    }
  }

  /**
   * Handle incoming WebSocket messages
   */
  private handleWebSocketMessage(message: ModernPentestWSMessage) {
    const event = new CustomEvent(`modern-pentest:${message.type}`, {
      detail: message
    });
    window.dispatchEvent(event);
  }

  /**
   * Generic API request handler with error handling
   */
  private async makeRequest<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ModernPentestApiResponse<T>> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': this.activeSession || '',
          'X-Perplexity-Key': this.perplexityApiKey || '',
          ...options.headers
        }
      });

      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || `HTTP ${response.status}`);
      }

      return {
        success: true,
        data,
        timestamp: new Date().toISOString(),
        sessionId: this.activeSession || undefined
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * Set Perplexity API key for research capabilities
   */
  setPerplexityApiKey(apiKey: string) {
    this.perplexityApiKey = apiKey;
  }

  // ========== SESSION MANAGEMENT ==========

  /**
   * Create Modern Penetration Test Session
   */
  async createSession(session: Omit<ModernPentestSession, 'id' | 'findings' | 'evidence'>): Promise<ModernPentestApiResponse<ModernPentestSession>> {
    const response = await this.makeRequest<ModernPentestSession>('/api/v2/pentest/sessions', {
      method: 'POST',
      body: JSON.stringify(session)
    });
    
    if (response.success && response.data?.id) {
      this.activeSession = response.data.id;
    }
    
    return response;
  }

  /**
   * Get Session Status
   */
  async getSessionStatus(sessionId: string): Promise<ModernPentestApiResponse<ModernPentestSession>> {
    return this.makeRequest(`/api/v2/pentest/sessions/${sessionId}`);
  }

  /**
   * Stop Session
   */
  async stopSession(sessionId: string): Promise<ModernPentestApiResponse<{ message: string }>> {
    const response = await this.makeRequest<{ message: string }>(`/api/v2/pentest/sessions/${sessionId}/stop`, {
      method: 'POST'
    });
    
    if (response.success) {
      this.activeSession = null;
    }
    
    return response;
  }

  // ========== ACTIVE DIRECTORY TESTING ==========

  /**
   * Execute BloodHound Collection
   */
  async executeBloodHound(config: BloodHoundConfig & { sessionId: string }): Promise<ModernPentestApiResponse<ToolExecution>> {
    return this.makeRequest('/api/v2/pentest/ad/bloodhound', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Execute CrackMapExec
   */
  async executeCrackMapExec(config: CrackMapExecConfig & { sessionId: string; targets: string[] }): Promise<ModernPentestApiResponse<ToolExecution>> {
    return this.makeRequest('/api/v2/pentest/ad/crackmapexec', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Execute Mimikatz
   */
  async executeMimikatz(config: MimikatzConfig & { sessionId: string; target: string }): Promise<ModernPentestApiResponse<ToolExecution>> {
    return this.makeRequest('/api/v2/pentest/ad/mimikatz', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Get BloodHound Analysis
   */
  async getBloodHoundAnalysis(sessionId: string): Promise<ModernPentestApiResponse<{
    domainAdmins: any[];
    attackPaths: any[];
    highValueTargets: any[];
    kerberoastableUsers: any[];
    asrepRoastableUsers: any[];
  }>> {
    return this.makeRequest(`/api/v2/pentest/ad/bloodhound/analysis/${sessionId}`);
  }

  // ========== KUBERNETES SECURITY TESTING ==========

  /**
   * Execute kdigger Assessment
   */
  async executeKdigger(config: KdiggerConfig & { sessionId: string }): Promise<ModernPentestApiResponse<ToolExecution>> {
    return this.makeRequest('/api/v2/pentest/k8s/kdigger', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Execute kube-hunter
   */
  async executeKubeHunter(config: KubeHunterConfig & { sessionId: string }): Promise<ModernPentestApiResponse<ToolExecution>> {
    return this.makeRequest('/api/v2/pentest/k8s/kube-hunter', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Execute kube-bench
   */
  async executeKubeBench(config: KubeBenchConfig & { sessionId: string }): Promise<ModernPentestApiResponse<ToolExecution>> {
    return this.makeRequest('/api/v2/pentest/k8s/kube-bench', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Get K8s Cluster Information
   */
  async getK8sClusterInfo(sessionId: string): Promise<ModernPentestApiResponse<{
    version: string;
    nodes: any[];
    namespaces: any[];
    rbacEnabled: boolean;
    networkPolicies: boolean;
    securityContext: any;
  }>> {
    return this.makeRequest(`/api/v2/pentest/k8s/cluster-info/${sessionId}`);
  }

  // ========== NETWORK & WEB APPLICATION TESTING ==========

  /**
   * Execute Nmap Scan
   */
  async executeNmap(config: NmapConfig & { sessionId: string; targets: string[] }): Promise<ModernPentestApiResponse<ToolExecution>> {
    return this.makeRequest('/api/v2/pentest/network/nmap', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Execute Nuclei Scan
   */
  async executeNuclei(config: {
    sessionId: string;
    targets: string[];
    templates: string[];
    severity: string[];
  }): Promise<ModernPentestApiResponse<ToolExecution>> {
    return this.makeRequest('/api/v2/pentest/web/nuclei', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Execute SQLMap
   */
  async executeSQLMap(config: {
    sessionId: string;
    target: string;
    data?: string;
    cookie?: string;
    level: number;
    risk: number;
  }): Promise<ModernPentestApiResponse<ToolExecution>> {
    return this.makeRequest('/api/v2/pentest/web/sqlmap', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  // ========== HACKTRICKS METHODOLOGY ==========

  /**
   * Get HackTricks Phases
   */
  async getHackTricksPhases(targetType: string): Promise<ModernPentestApiResponse<HackTricksPhase[]>> {
    return this.makeRequest(`/api/v2/pentest/hacktricks/phases?targetType=${targetType}`);
  }

  /**
   * Get HackTricks Techniques
   */
  async getHackTricksTechniques(phaseId: string): Promise<ModernPentestApiResponse<HackTricksTechnique[]>> {
    return this.makeRequest(`/api/v2/pentest/hacktricks/techniques/${phaseId}`);
  }

  /**
   * Execute HackTricks Technique
   */
  async executeHackTricksTechnique(config: {
    sessionId: string;
    techniqueId: string;
    parameters: Record<string, any>;
  }): Promise<ModernPentestApiResponse<ToolExecution>> {
    return this.makeRequest('/api/v2/pentest/hacktricks/execute', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Query HackTricks with Perplexity
   */
  async queryHackTricks(query: string): Promise<ModernPentestApiResponse<{
    answer: string;
    sources: string[];
    relatedTechniques: string[];
  }>> {
    return this.makeRequest('/api/v2/pentest/hacktricks/query', {
      method: 'POST',
      body: JSON.stringify({ query })
    });
  }

  // ========== AI-POWERED ANALYSIS ==========

  /**
   * Analyze Findings with AI
   */
  async analyzeFindingsWithAI(config: {
    sessionId: string;
    aiConfig: AIAgentConfig;
    findings: ModernFinding[];
  }): Promise<ModernPentestApiResponse<{
    analysis: string;
    riskAssessment: string;
    recommendations: string[];
    attackPaths: string[];
  }>> {
    return this.makeRequest('/api/v2/pentest/ai/analyze', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Get AI Recommendations
   */
  async getAIRecommendations(config: {
    sessionId: string;
    currentPhase: string;
    executionHistory: ExecutionStep[];
  }): Promise<ModernPentestApiResponse<{
    nextSteps: string[];
    techniques: string[];
    tools: string[];
    reasoning: string;
  }>> {
    return this.makeRequest('/api/v2/pentest/ai/recommendations', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Research with Perplexity
   */
  async researchWithPerplexity(query: string): Promise<ModernPentestApiResponse<{
    answer: string;
    sources: string[];
    relatedQuestions: string[];
  }>> {
    if (!this.perplexityApiKey) {
      return {
        success: false,
        error: 'Perplexity API key not configured',
        timestamp: new Date().toISOString()
      };
    }

    try {
      const response = await fetch('https://api.perplexity.ai/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.perplexityApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'llama-3.1-sonar-large-128k-online',
          messages: [
            {
              role: 'system',
              content: 'You are a cybersecurity expert. Provide precise and actionable penetration testing guidance based on the latest techniques and tools.'
            },
            {
              role: 'user',
              content: query
            }
          ],
          temperature: 0.2,
          top_p: 0.9,
          max_tokens: 1000,
          return_images: false,
          return_related_questions: true,
          search_domain_filter: ['hacktricks.xyz', 'github.com', 'cve.mitre.org'],
          search_recency_filter: 'month',
          frequency_penalty: 1,
          presence_penalty: 0
        }),
      });

      const data = await response.json();
      
      return {
        success: true,
        data: {
          answer: data.choices[0]?.message?.content || '',
          sources: data.citations || [],
          relatedQuestions: data.related_questions || []
        },
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Perplexity request failed',
        timestamp: new Date().toISOString()
      };
    }
  }

  // ========== QUALITY ASSURANCE ==========

  /**
   * Get QA Checklist
   */
  async getQAChecklist(sessionId: string): Promise<ModernPentestApiResponse<QAChecklist[]>> {
    return this.makeRequest(`/api/v2/pentest/qa/checklist/${sessionId}`);
  }

  /**
   * Update QA Item
   */
  async updateQAItem(config: {
    sessionId: string;
    checklistId: string;
    itemId: string;
    completed: boolean;
    evidence?: string;
    notes?: string;
  }): Promise<ModernPentestApiResponse<{ message: string }>> {
    return this.makeRequest('/api/v2/pentest/qa/update', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Validate Compliance
   */
  async validateCompliance(sessionId: string): Promise<ModernPentestApiResponse<{
    compliant: boolean;
    frameworks: string[];
    gaps: string[];
    recommendations: string[];
  }>> {
    return this.makeRequest(`/api/v2/pentest/qa/compliance/${sessionId}`);
  }

  // ========== EVIDENCE MANAGEMENT ==========

  /**
   * Upload Evidence
   */
  async uploadEvidence(config: {
    sessionId: string;
    type: string;
    title: string;
    content: string;
    metadata: Record<string, any>;
  }): Promise<ModernPentestApiResponse<Evidence>> {
    return this.makeRequest('/api/v2/pentest/evidence', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Get Session Evidence
   */
  async getSessionEvidence(sessionId: string): Promise<ModernPentestApiResponse<Evidence[]>> {
    return this.makeRequest(`/api/v2/pentest/evidence/${sessionId}`);
  }

  // ========== REPORTING ==========

  /**
   * Generate Report
   */
  async generateReport(config: {
    sessionId: string;
    format: 'pdf' | 'html' | 'markdown' | 'docx';
    template: 'executive' | 'technical' | 'compliance';
    includeQA: boolean;
  }): Promise<ModernPentestApiResponse<{ reportUrl: string; reportId: string }>> {
    return this.makeRequest('/api/v2/pentest/reports/generate', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Get Session Findings
   */
  async getSessionFindings(sessionId: string): Promise<ModernPentestApiResponse<ModernFinding[]>> {
    return this.makeRequest(`/api/v2/pentest/findings/${sessionId}`);
  }

  /**
   * Get Execution History
   */
  async getExecutionHistory(sessionId: string): Promise<ModernPentestApiResponse<ExecutionStep[]>> {
    return this.makeRequest(`/api/v2/pentest/execution/${sessionId}`);
  }

  // ========== TOOL STATUS & HEALTH ==========

  /**
   * Get Tool Status
   */
  async getToolStatus(): Promise<ModernPentestApiResponse<{
    tools: Array<{
      name: string;
      status: 'available' | 'busy' | 'offline';
      version: string;
      lastUsed: string;
    }>;
    resources: {
      cpu: number;
      memory: number;
      disk: number;
    };
  }>> {
    return this.makeRequest('/api/v2/pentest/tools/status');
  }

  /**
   * Health Check
   */
  async healthCheck(): Promise<ModernPentestApiResponse<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    services: Array<{
      name: string;
      status: string;
      responseTime: number;
    }>;
    timestamp: string;
  }>> {
    return this.makeRequest('/api/v2/pentest/health');
  }

  // ========== CLEANUP ==========

  /**
   * Cleanup resources
   */
  cleanup() {
    if (this.wsConnection) {
      this.wsConnection.close();
      this.wsConnection = null;
    }
    this.activeSession = null;
    this.perplexityApiKey = null;
  }
}

// Export singleton instance
export const modernPentestApi = new ModernPentestApiService();

// Cleanup on page unload
if (typeof window !== 'undefined') {
  window.addEventListener('beforeunload', () => {
    modernPentestApi.cleanup();
  });
}