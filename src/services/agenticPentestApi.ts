/**
 * Agentic Penetration Testing API Service
 * AI-Powered Autonomous Security Assessment System
 * 
 * PRODUCTION REQUIREMENTS:
 * 1. Kali Linux environment with all tools installed
 * 2. Docker containers for tool isolation and security
 * 3. LLM API integration (OpenAI GPT-5, Claude Sonnet 4, or Perplexity)
 * 4. Command execution sandboxing and monitoring
 * 5. Real-time logging and audit trails
 * 6. Network isolation and traffic monitoring
 * 7. Evidence collection and secure storage
 * 8. Compliance reporting and attestation
 * 
 * SECURITY CONSIDERATIONS:
 * - All tool executions run in isolated Docker containers
 * - Command validation and sanitization before execution
 * - Network segmentation for testing environments
 * - Encrypted storage for sensitive findings and evidence
 * - Rate limiting and resource constraints
 * - Human approval gates for destructive operations
 * - Comprehensive audit logging
 * - Secure credential management
 */

import { 
  AgenticPentestSession,
  AIAgentConfig,
  KaliToolConfig,
  PentestTarget,
  AgenticFinding,
  ExecutionStep,
  AgenticLog,
  AgenticPentestApiResponse,
  AgenticPentestWSMessage,
  NmapConfig,
  SQLMapConfig,
  NiktoConfig,
  AmassConfig,
  Sn1perConfig
} from '@/types/agenticPentest';

/**
 * Main Agentic Penetration Testing Service
 * Coordinates AI decision making with Kali Linux tool execution
 */
class AgenticPentestApiService {
  private baseUrl: string;
  private wsConnection: WebSocket | null = null;
  private activeSessions: Map<string, AgenticPentestSession> = new Map();
  private llmApiKey: string = '';
  private llmProvider: 'openai' | 'anthropic' | 'perplexity' = 'openai';

  constructor() {
    // K8s service discovery or local development
    this.baseUrl = import.meta.env?.PROD
      ? 'https://agentic-pentest.security.svc.cluster.local'
      : 'http://localhost:3003';
    
    this.initializeWebSocket();
    this.loadConfiguration();
  }

  /**
   * Initialize WebSocket connection for real-time session updates
   */
  private initializeWebSocket() {
    const wsUrl = this.baseUrl.replace('http', 'ws') + '/agentic/ws';
    
    try {
      this.wsConnection = new WebSocket(wsUrl);
      
      this.wsConnection.onopen = () => {
        console.log('ü§ñ Agentic Pentest WebSocket connected');
      };
      
      this.wsConnection.onmessage = (event) => {
        const message: AgenticPentestWSMessage = JSON.parse(event.data);
        this.handleWebSocketMessage(message);
      };
      
      this.wsConnection.onclose = () => {
        console.log('ü§ñ Agentic Pentest WebSocket disconnected');
        this.scheduleReconnect();
      };
      
    } catch (error) {
      console.error('‚ùå Failed to initialize agentic pentest WebSocket:', error);
    }
  }

  /**
   * Handle incoming WebSocket messages for real-time updates
   */
  private handleWebSocketMessage(message: AgenticPentestWSMessage) {
    // Update local session state
    if (this.activeSessions.has(message.sessionId)) {
      const session = this.activeSessions.get(message.sessionId)!;
      
      switch (message.type) {
        case 'phase_change':
          session.phase = message.data.phase;
          break;
        case 'finding_discovered':
          session.findings.push(message.data.finding);
          break;
        case 'tool_execution':
          session.executionHistory.push(message.data.step);
          break;
        case 'ai_decision':
          session.logs.push({
            id: crypto.randomUUID(),
            timestamp: new Date().toISOString(),
            level: 'info',
            category: 'ai_decision',
            message: message.data.decision,
            aiContext: message.aiAgent ? {
              prompt: message.data.decision || 'AI Decision',
              response: message.aiAgent.nextAction,
              reasoning: message.aiAgent.reasoning,
              confidence: message.aiAgent.confidence
            } : undefined
          });
          break;
      }
      
      this.activeSessions.set(message.sessionId, session);
    }

    // Dispatch custom event for UI updates
    const event = new CustomEvent(`agentic_pentest:${message.type}`, {
      detail: message
    });
    window.dispatchEvent(event);
  }

  /**
   * Schedule WebSocket reconnection
   */
  private scheduleReconnect() {
    setTimeout(() => {
      console.log('üîÑ Attempting agentic pentest WebSocket reconnection...');
      this.initializeWebSocket();
    }, 5000);
  }

  /**
   * Load configuration from environment or prompt user
   */
  private loadConfiguration() {
    // Try to load from environment first
    this.llmApiKey = import.meta.env?.VITE_LLM_API_KEY || '';
    this.llmProvider = (import.meta.env?.VITE_LLM_PROVIDER as any) || 'openai';

    // If no API key, we'll prompt the user in the UI
    if (!this.llmApiKey) {
      console.warn('‚ö†Ô∏è No LLM API key found. User will be prompted to enter one.');
    }
  }

  /**
   * Generic API request handler with retry logic
   */
  private async makeRequest<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<AgenticPentestApiResponse<T>> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          'X-LLM-API-Key': this.llmApiKey,
          'X-LLM-Provider': this.llmProvider,
          ...options.headers
        }
      });

      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || `HTTP ${response.status}`);
      }

      return {
        success: true,
        data,
        timestamp: new Date().toISOString(),
        sessionId: data.sessionId || ''
      };

    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
        sessionId: ''
      };
    }
  }

  /**
   * Set LLM API key and provider
   */
  setLLMConfiguration(apiKey: string, provider: 'openai' | 'anthropic' | 'perplexity') {
    this.llmApiKey = apiKey;
    this.llmProvider = provider;
  }

  /**
   * Create new agentic penetration test session
   * Backend Endpoint: POST /api/agentic/sessions
   */
  async createSession(config: {
    name: string;
    description: string;
    target: PentestTarget;
    methodology: 'owasp' | 'nist' | 'cis' | 'ptes' | 'custom';
    aiAgent: AIAgentConfig;
    tools: KaliToolConfig[];
    automaticMode: boolean;
  }): Promise<AgenticPentestApiResponse<AgenticPentestSession>> {
    const sessionData = {
      ...config,
      id: crypto.randomUUID(),
      status: 'planning' as const,
      phase: {
        current: 'information_gathering' as const,
        completed: [],
        nextSteps: ['Network Discovery', 'Port Scanning', 'Service Enumeration'],
        aiRecommendations: [],
        estimatedTimeRemaining: 120
      },
      findings: [],
      executionHistory: [],
      timeline: {
        started: new Date().toISOString(),
        estimated_completion: new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString()
      },
      configuration: {
        maxDuration: 4,
        maxFindings: 100,
        automaticMode: config.automaticMode,
        notifications: {
          criticalFindings: true,
          phaseCompletion: true,
          errors: true,
          approvalRequired: !config.automaticMode
        },
        reporting: {
          format: 'html' as const,
          includeEvidence: true,
          executiveSummary: true,
          technicalDetails: true,
          remediationPlan: true
        },
        compliance: {
          frameworks: ['OWASP', 'NIST'],
          requirements: [],
          attestation: true
        }
      },
      logs: []
    };

    const response = await this.makeRequest<AgenticPentestSession>('/api/agentic/sessions', {
      method: 'POST',
      body: JSON.stringify(sessionData)
    });

    if (response.success && response.data) {
      this.activeSessions.set(response.data.id, response.data);
    }

    return response;
  }

  /**
   * Start agentic penetration test execution
   * Backend Endpoint: POST /api/agentic/sessions/{sessionId}/start
   */
  async startSession(sessionId: string): Promise<AgenticPentestApiResponse<{ message: string }>> {
    return this.makeRequest(`/api/agentic/sessions/${sessionId}/start`, {
      method: 'POST'
    });
  }

  /**
   * Get AI analysis of Nmap scan results
   * Backend Endpoint: POST /api/agentic/analyze/nmap
   */
  async analyzeNmapResults(config: {
    sessionId: string;
    nmapOutput: string;
    target: string;
    scanType: string;
  }): Promise<AgenticPentestApiResponse<{
    analysis: string;
    findings: AgenticFinding[];
    nextSteps: string[];
    recommendedTools: string[];
    confidence: number;
  }>> {
    return this.makeRequest('/api/agentic/analyze/nmap', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Execute AI-recommended next step
   * Backend Endpoint: POST /api/agentic/execute/step
   */
  async executeRecommendedStep(config: {
    sessionId: string;
    step: string;
    tool: string;
    parameters: Record<string, any>;
    reasoning: string;
  }): Promise<AgenticPentestApiResponse<ExecutionStep>> {
    return this.makeRequest('/api/agentic/execute/step', {
      method: 'POST',
      body: JSON.stringify(config)
    });
  }

  /**
   * Run automated Nmap scan with AI optimization
   * Backend Endpoint: POST /api/agentic/tools/nmap
   */
  async runNmapScan(config: {
    sessionId: string;
    target: string;
    scanType?: string;
    aiOptimized?: boolean;
  }): Promise<AgenticPentestApiResponse<{
    executionId: string;
    command: string;
    estimatedDuration: number;
  }>> {
    const nmapConfig: NmapConfig = {
      name: 'nmap',
      version: '7.94',
      enabled: true,
      priority: 9,
      configuration: {
        scanType: config.scanType as any || 'syn',
        ports: 'top-ports 1000',
        timing: '4',
        scripts: ['default', 'safe'],
        outputFormat: 'xml',
        osDetection: true,
        serviceVersion: true,
        aggressive: false,
        stealth: false,
        fragmentPackets: false,
        decoyScans: false,
        spoofSource: false
      },
      resourceLimits: {
        maxExecutionTime: 1800,
        maxMemoryUsage: 512,
        maxCpuUsage: 50
      },
      safety: {
        destructive: false,
        requiresConfirmation: false,
        allowedTargets: [config.target],
        blockedTargets: []
      }
    };

    return this.makeRequest('/api/agentic/tools/nmap', {
      method: 'POST',
      body: JSON.stringify({
        sessionId: config.sessionId,
        target: config.target,
        config: nmapConfig,
        aiOptimized: config.aiOptimized || true
      })
    });
  }

  /**
   * Run SQLMap with AI guidance
   * Backend Endpoint: POST /api/agentic/tools/sqlmap
   */
  async runSQLMapScan(config: {
    sessionId: string;
    target: string;
    parameters?: string[];
    aiGuided?: boolean;
  }): Promise<AgenticPentestApiResponse<{
    executionId: string;
    command: string;
    estimatedDuration: number;
  }>> {
    const sqlmapConfig: SQLMapConfig = {
      name: 'sqlmap',
      version: '1.7.11',
      enabled: true,
      priority: 8,
      configuration: {
        target: config.target,
        testParameters: config.parameters || ['*'],
        dbms: 'auto',
        technique: 'BEUSTQ',
        level: 1,
        risk: 1,
        threads: 1,
        dumpData: false,
        dumpAll: false,
        batch: true,
        tamper: [],
        userAgent: 'Mozilla/5.0 (compatible; AgenticPentest/1.0)',
        headers: {},
        cookies: '',
        proxy: ''
      },
      resourceLimits: {
        maxExecutionTime: 3600,
        maxMemoryUsage: 1024,
        maxCpuUsage: 30
      },
      safety: {
        destructive: true,
        requiresConfirmation: true,
        allowedTargets: [config.target],
        blockedTargets: []
      }
    };

    return this.makeRequest('/api/agentic/tools/sqlmap', {
      method: 'POST',
      body: JSON.stringify({
        sessionId: config.sessionId,
        config: sqlmapConfig,
        aiGuided: config.aiGuided || true
      })
    });
  }

  /**
   * Run Nikto web server scan
   * Backend Endpoint: POST /api/agentic/tools/nikto
   */
  async runNiktoScan(config: {
    sessionId: string;
    target: string;
    port?: number;
    ssl?: boolean;
  }): Promise<AgenticPentestApiResponse<{
    executionId: string;
    command: string;
    estimatedDuration: number;
  }>> {
    const niktoConfig: NiktoConfig = {
      name: 'nikto',
      version: '2.5.0',
      enabled: true,
      priority: 7,
      configuration: {
        target: config.target,
        port: config.port || 80,
        ssl: config.ssl || false,
        plugins: ['all'],
        tuning: '1234567890abcde',
        maxtime: 1800,
        timeout: 10,
        useragent: 'Mozilla/5.0 (compatible; AgenticPentest/1.0)',
        cookies: '',
        headers: {},
        proxy: '',
        output: 'json'
      },
      resourceLimits: {
        maxExecutionTime: 2400,
        maxMemoryUsage: 256,
        maxCpuUsage: 25
      },
      safety: {
        destructive: false,
        requiresConfirmation: false,
        allowedTargets: [config.target],
        blockedTargets: []
      }
    };

    return this.makeRequest('/api/agentic/tools/nikto', {
      method: 'POST',
      body: JSON.stringify({
        sessionId: config.sessionId,
        config: niktoConfig
      })
    });
  }

  /**
   * Run Amass for subdomain enumeration
   * Backend Endpoint: POST /api/agentic/tools/amass
   */
  async runAmassEnum(config: {
    sessionId: string;
    domain: string;
    passive?: boolean;
    active?: boolean;
  }): Promise<AgenticPentestApiResponse<{
    executionId: string;
    command: string;
    estimatedDuration: number;
  }>> {
    const amassConfig: AmassConfig = {
      name: 'amass',
      version: '4.2.0',
      enabled: true,
      priority: 8,
      configuration: {
        mode: 'enum',
        domain: config.domain,
        passive: config.passive !== false,
        active: config.active || false,
        bruteforce: false,
        wordlists: ['/usr/share/amass/wordlists/all.txt'],
        resolvers: [],
        sources: ['crtsh', 'hackertarget', 'virustotal'],
        timeout: 60,
        maxDNSQueries: 20000,
        alterations: true,
        minForRecursive: 1
      },
      resourceLimits: {
        maxExecutionTime: 3600,
        maxMemoryUsage: 512,
        maxCpuUsage: 40
      },
      safety: {
        destructive: false,
        requiresConfirmation: false,
        allowedTargets: [config.domain],
        blockedTargets: []
      }
    };

    return this.makeRequest('/api/agentic/tools/amass', {
      method: 'POST',
      body: JSON.stringify({
        sessionId: config.sessionId,
        config: amassConfig
      })
    });
  }

  /**
   * Run Sn1per automated framework
   * Backend Endpoint: POST /api/agentic/tools/sn1per
   */
  async runSn1perScan(config: {
    sessionId: string;
    target: string;
    mode?: 'stealth' | 'flyover' | 'airstrike' | 'discover';
    workspace?: string;
  }): Promise<AgenticPentestApiResponse<{
    executionId: string;
    command: string;
    estimatedDuration: number;
  }>> {
    const sn1perConfig: Sn1perConfig = {
      name: 'sn1per',
      version: '10.0',
      enabled: true,
      priority: 9,
      configuration: {
        mode: config.mode || 'stealth',
        target: config.target,
        workspace: config.workspace || `agentic_${Date.now()}`,
        threads: 10,
        timeout: 3600,
        bruteforce: true,
        osint: true,
        recon: true,
        vulnscan: true,
        exploitscan: false,
        reporting: true
      },
      resourceLimits: {
        maxExecutionTime: 7200,
        maxMemoryUsage: 2048,
        maxCpuUsage: 60
      },
      safety: {
        destructive: false,
        requiresConfirmation: true,
        allowedTargets: [config.target],
        blockedTargets: []
      }
    };

    return this.makeRequest('/api/agentic/tools/sn1per', {
      method: 'POST',
      body: JSON.stringify({
        sessionId: config.sessionId,
        config: sn1perConfig
      })
    });
  }

  /**
   * Get session status and real-time updates
   * Backend Endpoint: GET /api/agentic/sessions/{sessionId}
   */
  async getSessionStatus(sessionId: string): Promise<AgenticPentestApiResponse<AgenticPentestSession>> {
    return this.makeRequest(`/api/agentic/sessions/${sessionId}`);
  }

  /**
   * Get AI-generated executive summary
   * Backend Endpoint: GET /api/agentic/sessions/{sessionId}/report
   */
  async generateReport(sessionId: string, format: 'html' | 'pdf' | 'json' | 'markdown'): Promise<AgenticPentestApiResponse<{
    reportUrl: string;
    executiveSummary: string;
    findingsCount: number;
    riskScore: number;
  }>> {
    return this.makeRequest(`/api/agentic/sessions/${sessionId}/report?format=${format}`);
  }

  /**
   * Stop agentic penetration test session
   * Backend Endpoint: POST /api/agentic/sessions/{sessionId}/stop
   */
  async stopSession(sessionId: string): Promise<AgenticPentestApiResponse<{ message: string }>> {
    const response = await this.makeRequest<{ message: string }>(`/api/agentic/sessions/${sessionId}/stop`, {
      method: 'POST'
    });

    if (response.success) {
      this.activeSessions.delete(sessionId);
    }

    return response;
  }

  /**
   * Get active sessions
   */
  getActiveSessions(): AgenticPentestSession[] {
    return Array.from(this.activeSessions.values());
  }

  /**
   * Cleanup resources
   */
  cleanup() {
    if (this.wsConnection) {
      this.wsConnection.close();
      this.wsConnection = null;
    }
    this.activeSessions.clear();
  }
}

// Export singleton instance
export const agenticPentestApi = new AgenticPentestApiService();

// Cleanup on page unload
if (typeof window !== 'undefined') {
  window.addEventListener('beforeunload', () => {
    agenticPentestApi.cleanup();
  });
}